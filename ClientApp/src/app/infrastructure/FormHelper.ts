import { FormGroup, ValidationErrors } from '@angular/forms';
import { ModelBase } from '../models/ModelBase';
import { ValidationError } from './ValidationError';


export class FormHelper {
  // fill a FormGroup with values from a model object
  public static ReadModel<T extends ModelBase<T>>(model: T, formGroup: FormGroup): void {
    Object.keys(model).forEach(key => {
      if (formGroup.controls[key]) {
        formGroup.controls[key].setValue(model[key]);
      }
    });
  }

  // update the given model with values from the FormGroup
  public static UpdateModel<T extends ModelBase<T>>(modelType: new (m?: Partial<T>) => T, model: T, formGroup: FormGroup): void {
    let n = new modelType(formGroup.value);
    Object.keys(n).forEach(f => {
      // HACK: use null instead of empty string
      model[f] = n[f] === '' ? null : n[f];
    });
  }

  // display server validation errors on the corresponding FormControl
  // the error type is "server"
  public static ShowErrors(validationErrors: ValidationError[], formGroup: FormGroup) {
    validationErrors.forEach(error => {

      // check if the error is field specific
      if (error.fields && error.fields.length > 0) {
        error.fields.forEach(field => {

          // sanitize the fieldname to match form field name conventions
          let fieldName = field.substr(0, 1).toLowerCase() + field.substr(1);

          // check if the error was generated by the json serializer
          if ((/^\$\./).test(fieldName)) {
            fieldName = fieldName.substr(2);

            // TODO: further parse validation error message to generate a better error message
            error.message = "invalid value";
          }

          if (formGroup.controls[fieldName]) {
            let ves: ValidationErrors = {};
            ves["server"] = error.message;
            formGroup.controls[fieldName].setErrors(ves);
          }
        });
      }
    });
  }
}
